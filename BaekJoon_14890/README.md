# 14890 경사로 (삼성 역량 테스트)

이번 풀이는 해당 블로그의 글을 참고하야 학습한 후 작성했음을 밝힙니다.

[참고 블로그](http://www.hellogohn.com/post_one258)

하드코딩을 통해 너무 많은 flag를 사용하여 코드의 가독성 및 효율이 떨어졌다. 함수형 프로그래밍을 최대한 하려고 했지만 매개변수와 반환 값을 설정하는데 어려움이 있었다. 

## 접근법

> 규칙성을 찾는다 

- 경사로에 관한 규칙
	- L개의 발판이 있어야 경사로를 놓을 수 있다.
    - 무조건 1씩 차이가 나는 높이에서 경사로를 설치 할 수 있다.
- 배열 접근 방법
	- 기존 배열을 *2로 늘려 Transpose(전치) 행렬을 통해 행 접근 , 열 접근 시 메모리와 코드 양을 줄인다.
    
    ```java
	for(int i = 0; i < 2*N ; i++) {
      for(int j = 0 ; j < N; j++) {
        a[i + N][j] = a[j][i];
      }
    }
	//전치 한 후 예제
   	1 2 3 
   	4 5 6
    7 8 9
    1 4 7
    2 5 8  
    3 6 9  
    ```

- 풀이
	- 행을 기준으로 `map[i][j] == map[i][j+1]` 인 경우 : cnt를 늘린다
    - `map[i][j] + 1 == map[i][j+1]` 인 경우(주의 : 높이가 1씩 차이나야 하므로 < > 를 사용하면 안된다)
    	`cnt >= L` 가 만족 하면 cnt = 1 로 바꾼다
        cnt가 의미하는건 지금까지 온 길중 같은것이 존재할때마다 늘려준 양이다 즉 cnt는 경사로를 놓을때 판단해야하는 		발판의 개수가 된다. L보다 크거나 같으면 발판을 놓아도 되므로 cnt = 1로 바꾸어준다.
    - `map[i][j] - 1 == map[i][j+1]` 인 경우 `cnt >= 0`가 만족하면 cnt = -L + 1 로 바꾼다.
    	(예를 들어 L = 2이고 3 3 2 3 인 경우 3 -> 2 일때 cnt 가 양수 이므로 만족하고 cnt = -1이 된다. 그다		다음 2 -> 3을 만날때 두번째 if문에 걸리지 않고 종료 된다. (2번째 조건에 cnt >= L을 설정하는 이유)
    - 그 외에는 break 탈출
  	- 최종 : `if (j == N -1 && cnt >= 0)` 이 면 지나갈수 있다.
    
    
## 개선방향

> 이번 문제는 조건을 너무 추가하여 하드코딩이 되었기때문에 코드를 간결하게 하면서 핵심 조건만 나열한 후 접근 할 필요성을 느낀다.
